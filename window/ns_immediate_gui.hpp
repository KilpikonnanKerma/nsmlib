/*

	Copyright (C) 2025 Nico Rajala. All rights reserved.

	ns_immediate_gui.hpp

	An immediate mode GUI library for use with NSWindow library.

*/

#ifndef NS_IMMEDIATE_GUI_HPP
#define NS_IMMEDIATE_GUI_HPP

#include <windows.h>
#include <GL/gl.h>
#include <cstring>
#include <vector>
#include <algorithm>

#include "math/math.hpp"
using namespace NMATH;

namespace NSImgui {

	// 8x8 ASCII font (from https://github.com/dhepper/font8x8)
	static const unsigned char font8x8_basic[96][8] = {
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}, // (space)
		{0x18,0x3C,0x3C,0x18,0x18,0x00,0x18,0x00}, // !
		{0x36,0x36,0x00,0x00,0x00,0x00,0x00,0x00}, // "
		{0x36,0x36,0x7F,0x36,0x7F,0x36,0x36,0x00}, // #
		{0x0C,0x3E,0x03,0x1E,0x30,0x1F,0x0C,0x00}, // $
		{0x00,0x63,0x33,0x18,0x0C,0x66,0x63,0x00}, // %
		{0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x6E,0x00}, // &
		{0x06,0x06,0x03,0x00,0x00,0x00,0x00,0x00}, // '
		{0x18,0x0C,0x06,0x06,0x06,0x0C,0x18,0x00}, // (
		{0x06,0x0C,0x18,0x18,0x18,0x0C,0x06,0x00}, // )
		{0x00,0x66,0x3C,0xFF,0x3C,0x66,0x00,0x00}, // *
		{0x00,0x0C,0x0C,0x3F,0x0C,0x0C,0x00,0x00}, // +
		{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x06}, // ,
		{0x00,0x00,0x00,0x3F,0x00,0x00,0x00,0x00}, // -
		{0x00,0x00,0x00,0x00,0x00,0x0C,0x0C,0x00}, // .
		{0x60,0x30,0x18,0x0C,0x06,0x03,0x01,0x00}, // /
		{0x3E,0x63,0x73,0x7B,0x6F,0x67,0x3E,0x00}, // 0
		{0x0C,0x0E,0x0C,0x0C,0x0C,0x0C,0x3F,0x00}, // 1
		{0x1E,0x33,0x30,0x1C,0x06,0x33,0x3F,0x00}, // 2
		{0x1E,0x33,0x30,0x1C,0x30,0x33,0x1E,0x00}, // 3
		{0x38,0x3C,0x36,0x33,0x7F,0x30,0x78,0x00}, // 4
		{0x3F,0x03,0x1F,0x30,0x30,0x33,0x1E,0x00}, // 5
		{0x1C,0x06,0x03,0x1F,0x33,0x33,0x1E,0x00}, // 6
		{0x3F,0x33,0x30,0x18,0x0C,0x0C,0x0C,0x00}, // 7
		{0x1E,0x33,0x33,0x1E,0x33,0x33,0x1E,0x00}, // 8
		{0x1E,0x33,0x33,0x3E,0x30,0x18,0x0E,0x00}, // 9
		{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x00}, // :
		{0x00,0x0C,0x0C,0x00,0x00,0x0C,0x0C,0x06}, // ;
		{0x18,0x0C,0x06,0x03,0x06,0x0C,0x18,0x00}, // <
		{0x00,0x00,0x3F,0x00,0x00,0x3F,0x00,0x00}, // =
		{0x06,0x0C,0x18,0x30,0x18,0x0C,0x06,0x00}, // >
		{0x1E,0x33,0x30,0x18,0x0C,0x00,0x0C,0x00}, // ?
		{0x3E,0x63,0x7B,0x7B,0x7B,0x03,0x1E,0x00}, // @
		{0x0C,0x1E,0x33,0x33,0x3F,0x33,0x33,0x00}, // A
		{0x3F,0x66,0x66,0x3E,0x66,0x66,0x3F,0x00}, // B
		{0x3C,0x66,0x03,0x03,0x03,0x66,0x3C,0x00}, // C
		{0x1F,0x36,0x66,0x66,0x66,0x36,0x1F,0x00}, // D
		{0x7F,0x46,0x16,0x1E,0x16,0x46,0x7F,0x00}, // E
		{0x7F,0x46,0x16,0x1E,0x16,0x06,0x0F,0x00}, // F
		{0x3C,0x66,0x03,0x03,0x73,0x66,0x7C,0x00}, // G
		{0x33,0x33,0x33,0x3F,0x33,0x33,0x33,0x00}, // H
		{0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00}, // I
		{0x78,0x30,0x30,0x30,0x33,0x33,0x1E,0x00}, // J
		{0x67,0x66,0x36,0x1E,0x36,0x66,0x67,0x00}, // K
		{0x0F,0x06,0x06,0x06,0x46,0x66,0x7F,0x00}, // L
		{0x63,0x77,0x7F,0x7F,0x6B,0x63,0x63,0x00}, // M
		{0x63,0x67,0x6F,0x7B,0x73,0x63,0x63,0x00}, // N
		{0x1C,0x36,0x63,0x63,0x63,0x36,0x1C,0x00}, // O
		{0x3F,0x66,0x66,0x3E,0x06,0x06,0x0F,0x00}, // P
		{0x1E,0x33,0x33,0x33,0x3B,0x1E,0x38,0x00}, // Q
		{0x3F,0x66,0x66,0x3E,0x36,0x66,0x67,0x00}, // R
		{0x1E,0x33,0x07,0x0E,0x38,0x33,0x1E,0x00}, // S
		{0x3F,0x2D,0x0C,0x0C,0x0C,0x0C,0x1E,0x00}, // T
		{0x33,0x33,0x33,0x33,0x33,0x33,0x3F,0x00}, // U
		{0x33,0x33,0x33,0x33,0x33,0x1E,0x0C,0x00}, // V
		{0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00}, // W
		{0x63,0x63,0x36,0x1C,0x1C,0x36,0x63,0x00}, // X
		{0x33,0x33,0x33,0x1E,0x0C,0x0C,0x1E,0x00}, // Y
		{0x7F,0x63,0x31,0x18,0x4C,0x66,0x7F,0x00}, // Z
		{0x1E,0x06,0x06,0x06,0x06,0x06,0x1E,0x00}, // [
		{0x03,0x06,0x0C,0x18,0x30,0x60,0x40,0x00}, // backslash
		{0x1E,0x18,0x18,0x18,0x18,0x18,0x1E,0x00}, // ]
		{0x08,0x1C,0x36,0x63,0x00,0x00,0x00,0x00}, // ^
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF}, // _
		{0x0C,0x0C,0x18,0x00,0x00,0x00,0x00,0x00}, // `
		{0x00,0x00,0x1E,0x30,0x3E,0x33,0x6E,0x00}, // a
		{0x07,0x06,0x06,0x3E,0x66,0x66,0x3B,0x00}, // b
		{0x00,0x00,0x1E,0x33,0x03,0x33,0x1E,0x00}, // c
		{0x38,0x30,0x30,0x3e,0x33,0x33,0x6E,0x00}, // d
		{0x00,0x00,0x1E,0x33,0x3f,0x03,0x1E,0x00}, // e
		{0x1C,0x36,0x06,0x0f,0x06,0x06,0x0F,0x00}, // f
		{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x1F}, // g
		{0x07,0x06,0x36,0x6E,0x66,0x66,0x67,0x00}, // h
		{0x0C,0x00,0x0E,0x0C,0x0C,0x0C,0x1E,0x00}, // i
		{0x30,0x00,0x30,0x30,0x30,0x33,0x33,0x1E}, // j
		{0x07,0x06,0x66,0x36,0x1E,0x36,0x67,0x00}, // k
		{0x0E,0x0C,0x0C,0x0C,0x0C,0x0C,0x1E,0x00}, // l
		{0x00,0x00,0x33,0x7F,0x7F,0x6B,0x63,0x00}, // m
		{0x00,0x00,0x1F,0x33,0x33,0x33,0x33,0x00}, // n
		{0x00,0x00,0x1E,0x33,0x33,0x33,0x1E,0x00}, // o
		{0x00,0x00,0x3B,0x66,0x66,0x3E,0x06,0x0F}, // p
		{0x00,0x00,0x6E,0x33,0x33,0x3E,0x30,0x78}, // q
		{0x00,0x00,0x3B,0x6E,0x66,0x06,0x0F,0x00}, // r
		{0x00,0x00,0x3E,0x03,0x1E,0x30,0x1F,0x00}, // s
		{0x08,0x0C,0x3E,0x0C,0x0C,0x2C,0x18,0x00}, // t
		{0x00,0x00,0x33,0x33,0x33,0x33,0x6E,0x00}, // u
		{0x00,0x00,0x33,0x33,0x33,0x1E,0x0C,0x00}, // v
		{0x00,0x00,0x63,0x6B,0x7F,0x7F,0x36,0x00}, // w
		{0x00,0x00,0x63,0x36,0x1C,0x36,0x63,0x00}, // x
		{0x00,0x00,0x33,0x33,0x33,0x3E,0x30,0x1F}, // y
		{0x00,0x00,0x3F,0x19,0x0C,0x26,0x3F,0x00}, // z
		{0x38,0x0C,0x0C,0x07,0x0C,0x0C,0x38,0x00}, // {
		{0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x00}, // |
		{0x07,0x0C,0x0C,0x38,0x0C,0x0C,0x07,0x00}, // }
		{0x6E,0x3B,0x00,0x00,0x00,0x00,0x00,0x00}, // ~
		{0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00}  // (del)
	};

	struct State {
		int mouseX, mouseY;
		bool mouseDown, mousePressed, mouseReleased;
		int hotItem, activeItem, lastWidget;
	};

	inline State& GetState() {
		static State state;
		return state;
	}

	inline void NewFrame(int mouseX, int mouseY, bool mouseDown, bool mousePressed, bool mouseReleased) {
		State& s = GetState();
		s.mouseX = mouseX;
		s.mouseY = mouseY;
		s.mouseDown = mouseDown;
		s.mousePressed = mousePressed;
		s.mouseReleased = mouseReleased;
		s.hotItem = 0;
		s.lastWidget = 0;
	}

	inline void EndFrame() {
		State& s = GetState();
		if (s.mouseReleased)
			s.activeItem = 0;
	}

	inline void DrawRect(float x, float y, float w, float h, float r, float g, float b, float a = 1.0f) {
		glColor4f(r, g, b, a);
		glBegin(GL_QUADS);
		glVertex2f(x, y);
		glVertex2f(x + w, y);
		glVertex2f(x + w, y + h);
		glVertex2f(x, y + h);
		glEnd();
	}

	inline void DrawRectOutline(float x, float y, float w, float h, float r, float g, float b) {
		glColor3f(r, g, b);
		glBegin(GL_LINE_LOOP);
		glVertex2f(x, y);
		glVertex2f(x + w, y);
		glVertex2f(x + w, y + h);
		glVertex2f(x, y + h);
		glEnd();
	}

	inline void DrawChar(float x, float y, char c, float r, float g, float b) {
		if (c < 32 || c > 127) return;
		const unsigned char* bitmap = font8x8_basic[c - 32];
		glColor3f(r, g, b);
		for (int row = 0; row < 8; ++row) {
			for (int col = 0; col < 8; ++col) {
				if (bitmap[row] & (1 << col)) {
					float px = x + col;
					float py = y + row;
					glBegin(GL_QUADS);
					glVertex2f(px, py);
					glVertex2f(px + 1, py);
					glVertex2f(px + 1, py + 1);
					glVertex2f(px, py + 1);
					glEnd();
				}
			}
		}
	}

	inline void DrawText(float x, float y, const char* text, float r = 0, float g = 0, float b = 0) {
		float cx = x;
		for (const char* c = text; *c; ++c, cx += 8.0f)
			DrawChar(cx, y, *c, r, g, b);
	}

	struct WindowState {
		char title[64];
		float x, y, w, h;
		bool open;
		bool moving = false;
		bool resizing = false;
		float moveOffsetX = 0, moveOffsetY = 0;
		float resizeStartW = 0, resizeStartH = 0;
		float resizeStartX = 0, resizeStartY = 0;
	};

	inline std::vector<WindowState>& GetWindows() {
		static std::vector<WindowState> windows;
		return windows;
	}

	inline WindowState* FindWindow(const char* title) {
		auto& ws = GetWindows();
		for (auto& w : ws)
			if (std::strcmp(w.title, title) == 0)
				return &w;
		return nullptr;
	}

	inline WindowState* CreateOrGetWindow(const char* title, float x, float y, float w, float h) {
		WindowState* win = FindWindow(title);
		if (!win) {
			GetWindows().push_back(WindowState{});
			win = &GetWindows().back();
			std::strncpy(win->title, title, 63);
			win->title[63] = 0;
			win->x = x; win->y = y; win->w = w; win->h = h; win->open = true;
		}
		return win;
	}

	struct Layout {
		float cursorX, cursorY, startX, startY, availW;
		float spacingY;
		WindowState* win;
	};

	inline Layout*& GetLayout() {
		static Layout* layout = nullptr;
		return layout;
	}

	inline bool BeginWindow(const char* title, float x, float y, float w, float h, float alpha, bool* pOpen = nullptr) {
		State& s = GetState();
		WindowState* win = CreateOrGetWindow(title, x, y, w, h);
		if (!win->open) return false;
		if (pOpen) *pOpen = win->open;

		// Window interaction
		float mx = (float)s.mouseX, my = (float)s.mouseY;
		bool titleHovered = mx >= win->x && mx <= win->x + win->w && my >= win->y && my <= win->y + 24;
		bool resizeHovered = mx >= win->x + win->w - 12 && mx <= win->x + win->w && my >= win->y + win->h - 12 && my <= win->y + win->h;
		bool closeHovered = mx >= win->x + win->w - 24 && mx <= win->x + win->w - 8 && my >= win->y + 4 && my <= win->y + 20;

		// Move
		if (titleHovered && s.mousePressed && !resizeHovered && !closeHovered) {
			win->moving = true;
			win->moveOffsetX = mx - win->x;
			win->moveOffsetY = my - win->y;
		}
		if (!s.mouseDown) win->moving = false;
		if (win->moving) {
			win->x = mx - win->moveOffsetX;
			win->y = my - win->moveOffsetY;
		}

		// Resize
		if (resizeHovered && s.mousePressed) {
			win->resizing = true;
			win->resizeStartW = win->w;
			win->resizeStartH = win->h;
			win->resizeStartX = mx;
			win->resizeStartY = my;
		}
		if (!s.mouseDown) win->resizing = false;
		if (win->resizing) {
			win->w = NMATH::maxf(128.0f, win->resizeStartW + (mx - win->resizeStartX));
			win->h = NMATH::maxf(96.0f, win->resizeStartH + (my - win->resizeStartY));
		}

		// Close
		if (closeHovered && s.mousePressed) {
			win->open = false;
			if (pOpen) *pOpen = false;
			return false;
		}

		// Draw window background and border
		DrawRect(win->x, win->y, win->w, win->h, 0.92f, 0.92f, 0.98f, alpha);
		DrawRectOutline(win->x, win->y, win->w, win->h, 0.2f, 0.2f, 0.3f);

		// Draw title bar
		DrawRect(win->x, win->y, win->w, 24, 0.35f, 0.45f, 0.65f);
		DrawRectOutline(win->x, win->y, win->w, 24, 0.2f, 0.2f, 0.3f);
		DrawText(win->x + 8, win->y + 8, title, 1, 1, 1);

		// Draw close button
		DrawRect(win->x + win->w - 24, win->y + 4, 16, 16, closeHovered ? 0.8f : 0.7f, 0.3f, 0.3f);
		DrawRectOutline(win->x + win->w - 24, win->y + 4, 16, 16, 0.2f, 0.2f, 0.3f);
		DrawText(win->x + win->w - 20, win->y + 8, "X", 1, 1, 1);

		// Draw resize handle
		DrawRect(win->x + win->w - 12, win->y + win->h - 12, 12, 12, resizeHovered ? 0.6f : 0.8f, 0.8f, 0.8f);
		DrawRectOutline(win->x + win->w - 12, win->y + win->h - 12, 12, 12, 0.2f, 0.2f, 0.3f);

		static Layout layout;
		layout.win = win;
		layout.startX = win->x + 8;
		layout.startY = win->y + 32;
		layout.cursorX = layout.startX;
		layout.cursorY = layout.startY;
		layout.availW = win->w - 16;
		layout.spacingY = 8;
		GetLayout() = &layout;

		return true;
	}

	inline void EndWindow() {
		GetLayout() = nullptr;
	}

	inline bool Button(const char* label, float x, float y, float w, float h) {
		State& s = GetState();
		int id = ++s.lastWidget;
		bool hovered = s.mouseX >= x && s.mouseX <= x + w && s.mouseY >= y && s.mouseY <= y + h;
		if (hovered) s.hotItem = id;
		bool pressed = false;

		if (hovered && s.mousePressed) s.activeItem = id;
		if (hovered && s.activeItem == id && s.mouseReleased) pressed = true;

		// Draw button
		if (s.activeItem == id && hovered)
			DrawRect(x, y, w, h, 0.6f, 0.6f, 0.8f);
		else if (hovered)
			DrawRect(x, y, w, h, 0.7f, 0.7f, 0.9f);
		else
			DrawRect(x, y, w, h, 0.8f, 0.8f, 0.95f);

		DrawRectOutline(x, y, w, h, 0.2f, 0.2f, 0.3f);

		// Center text
		float textWidth = (float)std::strlen(label) * 8.0f;
		DrawText(x + (w - textWidth) / 2, y + h / 2 - 4, label, 0, 0, 0);

		return pressed;
	}

	inline bool Checkbox(const char* label, bool* value, float x, float y) {
		State& s = GetState();
		int id = ++s.lastWidget;
		float boxSize = 16;
		bool hovered = s.mouseX >= x && s.mouseX <= x + boxSize && s.mouseY >= y && s.mouseY <= y + boxSize;
		if (hovered) s.hotItem = id;
		bool changed = false;

		if (hovered && s.mousePressed) s.activeItem = id;
		if (hovered && s.activeItem == id && s.mouseReleased) {
			*value = !*value;
			changed = true;
		}

		// Draw box
		DrawRect(x, y, boxSize, boxSize, 1, 1, 1);
		DrawRectOutline(x, y, boxSize, boxSize, 0.2f, 0.2f, 0.3f);
		if (*value) {
			DrawRect(x + 3, y + 3, boxSize - 6, boxSize - 6, 0.2f, 0.8f, 0.2f);
		}
		DrawText(x + boxSize + 6, y + boxSize - 4, label, 0, 0, 0);
		return changed;
	}

	// In window versions
	inline bool Button(const char* label, float w = 80, float h = 30) {
		Layout* l = GetLayout();
		if (!l) return false;
		float x = l->cursorX, y = l->cursorY;
		l->cursorY += h + l->spacingY;
		return Button(label, x, y, w, h);
	}

	inline bool Checkbox(const char* label, bool* value) {
		Layout* l = GetLayout();
		if (!l) return false;
		float x = l->cursorX, y = l->cursorY;
		l->cursorY += 16 + l->spacingY;
		return Checkbox(label, value, x, y);
	}

	// Call before drawing GUI widgets
	inline void BeginGUI(int fbWidth, int fbHeight) {
		glEnable(GL_BLEND);
		glBlendFunc(GL_SRC_ALPHA, GL_ONE_MINUS_SRC_ALPHA);
		glMatrixMode(GL_PROJECTION);
		glPushMatrix();
		glLoadIdentity();
		glOrtho(0, fbWidth, fbHeight, 0, -1, 1);
		glMatrixMode(GL_MODELVIEW);
		glPushMatrix();
		glLoadIdentity();
		glDisable(GL_DEPTH_TEST);
	}

	// Call after drawing GUI widgets
	inline void EndGUI() {
		glDisable(GL_BLEND);
		glEnable(GL_DEPTH_TEST);
		glMatrixMode(GL_MODELVIEW);
		glPopMatrix();
		glMatrixMode(GL_PROJECTION);
		glPopMatrix();
	}

} // namespace NSImgui

#endif